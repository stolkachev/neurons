<!doctype html>
<html>

<head>
    <title>NNOD Dialog Editor</title>

    <script type="text/javascript" src="js/vis.js"></script>
    <link href="nnod_editor.css" rel="stylesheet" type="text/css" />
</head>

<body onload="Page_Loaded();">
    <img src="js/img/256gl.png" height="101" width="432" style="position: absolute; top: 0px; left: 50px;">
    <div id="shapes"></div>
    <div id="nodes"></div>


    <script type="text/javascript">
        var nodes = null;
        var shapes = null;
        var edges = null;
        var shapes_edges = null;
        var network_of_nodes = null;
        var network_of_shapes = null;
        var current_shape = 'square'
        var exportValue = null;
        var resizeTimeOut;
        var get_Neurons_Url = "/get_neurons.php";
        var get_Nerves_Url = "/get_nerves.php";
        var neurons = null;
        var nevres = null;

        var container_of_nodes = document.getElementById('nodes');
        var container_of_shapes = document.getElementById('shapes');
        var options_nodes = null;
        var options_shapes = null;
        var data_nodes = null;
        var data_shapes = null;

        function draw_shapes() {
            shapes = new vis.DataSet();
            var x = 0;
            var y = 0;
            var step = 120;

            shapes.add({
                id: 1000,
                x: x,
                y: y,
                label: 'Starter',
                group: 'starter',
                value: 1,
                fixed: true,
                physics: false
            });
            shapes.add({
                id: 1001,
                x: x,
                y: y + step,
                label: 'Semaphore',
                group: 'sema',
                value: 1,
                fixed: true,
                physics: false
            });
            shapes.add({
                id: 1002,
                x: x,
                y: y + 2 * step,
                label: 'Prompt',
                group: 'question',
                value: 1,
                fixed: true,
                physics: false
            });
            shapes.add({
                id: 1003,
                x: x,
                y: y + 3 * step,
                label: 'Trigger',
                group: 'triggers',
                value: 1,
                fixed: true,
                physics: false
            });
            data_shapes = {
                nodes: shapes,
                edges: shapes_edges
            };
            options_shapes = {
                nodes: {
                    shape: 'dot',
                    fixed: {
                        y: true,
                        x: true
                    }
                },
                edges: {
                    color: 'gray',
                    smooth: false,
                },
                groups: {
                    starter: {
                        shape: 'ellipse',
                        color: '#FADBD8'
                    },
                    sema: {
                        shape: 'dot',
                        color: "#A9DFBF"
                    },
                    question: {
                        shape: 'square',
                        color: "#E5E7E9"
                    },
                    triggers: {
                        shape: 'star',
                        color: "#C5000B"
                    }
                },
                physics: {
                    enabled: false
                },
                interaction: {
                    hover: true,
                    zoomView: false,
                    dragView: false,
                },
                manipulation: {
                    enabled: false
                },
                layout: {
                    randomSeed: 0
                }
            };
            network_of_shapes = new vis.Network(container_of_shapes, data_shapes, options_shapes);
            network_of_shapes.on("selectNode", function(params) {
                console.log('selectNode Event:', params);
                if (params.nodes[0] >= 1000 && params.nodes[0] <= 1004) {
                    current_shape = network_of_shapes.clustering.body.nodes[params.nodes[0]].shape.constructor.name.toLowerCase();
                };

            });
        }

        function draw() {
            data_nodes = {
                nodes: nodes,
                edges: edges
            };

            options_nodes = {
                nodes: {
                    shape: 'dot'
                },
                edges: {
                    color: 'gray',
                    smooth: false,
                    arrows: {
                        to: {
                            enabled: true,
                            scaleFactor: 1,
                            type: 'arrow'
                        }
                    }
                },
                groups: {
                    starter: {
                        shape: 'ellipse',
                        color: '#FADBD8'
                    },
                    sema: {
                        shape: 'dot',
                        color: '#A9DFBF'
                    },
                    question: {
                        shape: 'square',
                        color: '#E5E7E9'
                    },
                    triggers: {
                        shape: 'star',
                        color: '#C5000B'
                    }
                },
                physics: {
                    enabled: false
                },
                interaction: {
                    hover: true,
                    zoomView: true
                },
                manipulation: {
                    enabled: true
                },
                layout: {
                    randomSeed: 0
                        // hierarchical: {
                        //     direction: 'UD',
                        //     sortMethod: 'directed'
                        // }
                }
            };
            network_of_nodes = new vis.Network(container_of_nodes, data_nodes, options_nodes);
            network_of_nodes.on("click", function(params) {
                var nodes = objectToArray(network_of_nodes.getPositions());
                nodes.forEach(addConnections);
                exportValue = JSON.stringify(nodes, undefined, 2);
                //               alert(exportValue)
            });
            network_of_nodes.on("doubleClick", function(params) {
                // params.event = "[original event]";
                // document.getElementById('eventSpan').innerHTML = '<h2>doubleClick event:</h2>' + JSON.stringify(params, null, 4);
            });

            network_of_nodes.on("select", function(params) {
                console.log('select Event:', params);
            });

            network_of_nodes.on("selectNode", function(params) {
                console.log('selectNode Event:', params);
                network_of_nodes.clustering.updateClusteredNode(params.nodes[0], {
                    shape: current_shape
                });
            });
        }

        window.onresize = function(event) {
            event.stopPropagation();
            event.preventDefault();
            clearTimeout(resizeTimeOut);
            resizeTimeOut = setTimeout(Redraw, 500);
            return false;
        };

        function Page_Loaded() {
            var xmlHttp = new XMLHttpRequest();
            xmlHttp.open("GET", get_Neurons_Url, false);
            xmlHttp.send(null);
            neurons = xmlHttp.responseText;
            xmlHttp.open("GET", get_Nerves_Url, false);
            xmlHttp.send(null);
            nevres = xmlHttp.responseText;
            var a_neurons = neurons.split("\n");
            var a_nerves = nevres.split("\n");

            nodes = new vis.DataSet();
            a_neurons.forEach(function(element) {
                var parts = element.split("\t");
                if (parts.length < 5) {
                    return;
                }
                nodes.add({
                    id: parts[0],
                    group: parts[2].toLowerCase(),
                    label: parts[3],
                    x: parts[4],
                    y: parts[5]
                });
            })
            edges = new vis.DataSet();
            a_nerves.forEach(function(element) {
                var parts = element.split("\t");
                if (parts.length < 3) {
                    return;
                }
                edges.add({
                    id: parts[0],
                    from: parts[1],
                    to: parts[2]
                });
            })

            //     alert(nevres);

            Init_Draw();
        }

        function Init_Draw() {
            var mynetwork = document.getElementById('nodes');
            var x1 = window.innerWidth - 100;
            var y1 = window.innerHeight - 130;
            mynetwork.style.width = x1 + "px";
            mynetwork.style.height = y1 + "px";
            mynetwork.style.left = "90px";
            draw_shapes()
            draw();
        }

        function Redraw() {
            network_of_nodes.destroy();
            var mynetwork = document.getElementById('nodes');
            var x1 = window.innerWidth - 100;
            var y1 = window.innerHeight - 130;
            mynetwork.style.width = x1 + "px";
            mynetwork.style.height = y1 + "px";
            mynetwork.style.left = "90px";

            var inputData = JSON.parse(exportValue);
            data_nodes = {
                nodes: getNodeData(inputData),
                edges: getEdgeData(inputData)
            }
            network_of_nodes = new vis.Network(container_of_nodes, data_nodes, options_nodes);
        };

        function objectToArray(obj) {
            return Object.keys(obj).map(function(key) {
                obj[key].id = key;
                return obj[key];
            });
        }

        function addConnections(elem, index) {
            var arr = [];
            edges.forEach(function(element) {
                if (element.from == elem.id) {
                    arr.push(element.to);
                }
            });
            elem.connections = arr;
        }

        function getNodeData(data) {
            var networkNodes = [];
            data.forEach(function(elem, index, array) {
                networkNodes.push({
                    id: elem.id,
                    label: elem.id,
                    x: elem.x,
                    y: elem.y
                });
            });

            return new vis.DataSet(networkNodes);
        }

        function getNodeById(data, id) {
            for (var n = 0; n < data.length; n++) {
                if (data[n].id == id) {
                    return data[n];
                }
            };
            throw 'Can not find id \'' + id + '\' in data';
        }

        function getEdgeData(data) {
            var networkEdges = [];
            data.forEach(function(node) {
                node.connections.forEach(function(connId, cIndex, conns) {
                    networkEdges.push({
                        from: node.id,
                        to: connId
                    });
                    let cNode = getNodeById(data, connId);

                    var elementConnections = cNode.connections;
                    var duplicateIndex = elementConnections.findIndex(function(connection) {
                        return connection == node.id;
                    });
                    if (duplicateIndex != -1) {
                        elementConnections.splice(duplicateIndex, 1);
                    };
                });
            });
            return new vis.DataSet(networkEdges);
        }
    </script>


</body>

</html>